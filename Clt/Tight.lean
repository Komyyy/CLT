/-
Copyright (c) 2025 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/
import Clt.CharFun
import Clt.Prokhorov

/-!
# Tightness and characteristic functions

-/

open MeasureTheory ProbabilityTheory Filter
open scoped ENNReal Topology RealInnerProductSpace

variable {E Œπ : Type*} {mE : MeasurableSpace E} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E]
  {Œº : Œπ ‚Üí Measure E} [‚àÄ i, IsProbabilityMeasure (Œº i)]

lemma equicontinuousAt_charFun_zero_of_isTightMeasureSet (hŒº : IsTightMeasureSet {Œº i | i}) :
    EquicontinuousAt (fun i ‚Ü¶ charFun (Œº i)) 0 := by
  sorry

lemma isTightMeasureSet_of_equicontinuousAt_charFun
    (hŒº : EquicontinuousAt (fun i ‚Ü¶ charFun (Œº i)) 0) :
    IsTightMeasureSet {Œº i | i} := by
  sorry

lemma isTightMeasureSet_iff_equicontinuousAt_charFun :
    IsTightMeasureSet {Œº i | i} ‚Üî EquicontinuousAt (fun i ‚Ü¶ charFun (Œº i)) 0 :=
  ‚ü®equicontinuousAt_charFun_zero_of_isTightMeasureSet,
    isTightMeasureSet_of_equicontinuousAt_charFun‚ü©

lemma isTightMeasureSet_of_tendsto_measure_norm_gt [BorelSpace E] [SecondCountableTopology E]
    [FiniteDimensional ‚Ñù E]
    {S : Set (Measure E)} (h : Tendsto (fun (r : ‚Ñù) ‚Ü¶ ‚®Ü Œº ‚àà S, Œº {x | r < ‚Äñx‚Äñ}) atTop (ùìù 0)) :
    IsTightMeasureSet S := by
  rw [IsTightMeasureSet_iff_exists_isCompact_measure_compl_le]
  intro Œµ hŒµ
  rw [ENNReal.tendsto_atTop_zero] at h
  obtain ‚ü®r, h‚ü© := h Œµ hŒµ
  specialize h r le_rfl
  refine ‚ü®Metric.closedBall 0 r, isCompact_closedBall 0 r, ?_‚ü©
  simp only [iSup_le_iff] at h
  convert h using 4 with Œº hŒº
  ext
  simp

lemma isTightMeasureSet_of_forall_basis_tendsto [BorelSpace E] [SecondCountableTopology E]
    [FiniteDimensional ‚Ñù E]
    {S : Set (Measure E)} (h_prob : ‚àÄ Œº ‚àà S, IsProbabilityMeasure Œº)
    (h : ‚àÄ i, Tendsto (fun (r : ‚Ñù) ‚Ü¶ ‚®Ü Œº ‚àà S, Œº {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|})
      atTop (ùìù 0)) :
    IsTightMeasureSet S := by
  refine isTightMeasureSet_of_tendsto_measure_norm_gt ?_
  sorry

lemma isTightMeasureSet_of_tendsto_limsup_measure_norm_gt [BorelSpace E] [SecondCountableTopology E]
    [FiniteDimensional ‚Ñù E]
    {Œº : ‚Ñï ‚Üí Measure E}
    (h : Tendsto (fun (r : ‚Ñù) ‚Ü¶ limsup (fun n ‚Ü¶ Œº n {x | r < ‚Äñx‚Äñ}) atTop) atTop (ùìù 0)) :
    IsTightMeasureSet {Œº n | n} := by
  sorry

lemma isTightMeasureSet_of_forall_basis_tendsto_limsup [BorelSpace E] [SecondCountableTopology E]
    [FiniteDimensional ‚Ñù E]
    {Œº : ‚Ñï ‚Üí Measure E} [‚àÄ n, IsProbabilityMeasure (Œº n)]
    (h : ‚àÄ i, Tendsto (fun (r : ‚Ñù) ‚Ü¶ limsup (fun n ‚Ü¶ Œº n {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|})
      atTop) atTop (ùìù 0)) :
    IsTightMeasureSet {Œº n | n} := by
  sorry

/-- Let $(\mu_n)_{n \in \mathbb{N}}$ be measures on $\mathbb{R}^d$ with characteristic functions
$(\hat{\mu}_n)$. If $\hat{\mu}_n$ converges pointwise to a function $f$ which is continuous at 0,
then $(\mu_n)$ is tight. -/
lemma isTightMeasureSet_of_tendsto_charFun [BorelSpace E] [SecondCountableTopology E]
    [FiniteDimensional ‚Ñù E]
    {Œº : ‚Ñï ‚Üí Measure E} [‚àÄ i, IsProbabilityMeasure (Œº i)]
    {f : E ‚Üí ‚ÑÇ} (hf : ContinuousAt f 0) (hf_meas : Measurable f)
    (h : ‚àÄ t, Tendsto (fun n ‚Ü¶ charFun (Œº n) t) atTop (ùìù (f t))) :
    IsTightMeasureSet {Œº i | i} := by
  refine isTightMeasureSet_of_forall_basis_tendsto_limsup fun i ‚Ü¶ ?_
  have h_le n r := measure_abs_inner_ge_le_charFun (Œº := Œº n) (a := Module.finBasis ‚Ñù E i) (r := r)
  suffices Tendsto (fun (r : ‚Ñù) ‚Ü¶
        limsup (fun n ‚Ü¶ (Œº n {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|}).toReal) atTop)
      atTop (ùìù 0) by
    have h_ofReal r : limsup (fun n ‚Ü¶ Œº n {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|}) atTop
        = ENNReal.ofReal
          (limsup (fun n ‚Ü¶ (Œº n {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|}).toReal) atTop) := by
      sorry
    simp_rw [h_ofReal]
    rw [‚Üê ENNReal.ofReal_zero]
    exact ENNReal.tendsto_ofReal this
  have h_limsup_le r (hr : 0 < r) :
      limsup (fun n ‚Ü¶ (Œº n {x | r < |‚ü™Module.finBasis ‚Ñù E i, x‚ü´|}).toReal) atTop
      ‚â§ 2‚Åª¬π * r * ‚Äñ‚à´ t in -2 * r‚Åª¬π..2 * r‚Åª¬π, 1 - f (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ := by
    -- This is where we use the fact that `charFun (Œº n)` converges to `f`
    sorry
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
    (h := fun r ‚Ü¶ 2‚Åª¬π * r * ‚Äñ‚à´ t in -2 * r‚Åª¬π..2 * r‚Åª¬π, 1 - f (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ)
    ?_ ?_ ?_
  rotate_left
  ¬∑ filter_upwards [eventually_gt_atTop 0] with r hr
    refine le_limsup_of_le ?_ fun u hu ‚Ü¶ ?_
    ¬∑ refine ‚ü®4, ?_‚ü©
      simp only [eventually_map, eventually_atTop, ge_iff_le]
      refine ‚ü®0, fun n _ ‚Ü¶ ?_‚ü©
      refine (h_le n r hr).trans ?_
      calc 2‚Åª¬π * r * ‚Äñ‚à´ t in -2 * r‚Åª¬π..2 * r‚Åª¬π, 1 - charFun (Œº n) (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ
      _ ‚â§ 2‚Åª¬π * r
          * ‚à´ t in -(2 * r‚Åª¬π)..2 * r‚Åª¬π, ‚Äñ1 - charFun (Œº n) (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ := by
        simp only [neg_mul, intervalIntegrable_const]
        gcongr
        rw [intervalIntegral.integral_of_le, intervalIntegral.integral_of_le]
        ¬∑ exact norm_integral_le_integral_norm _
        ¬∑ rw [neg_le_self_iff]; positivity
        ¬∑ rw [neg_le_self_iff]; positivity
      _ ‚â§ 2‚Åª¬π * r * ‚à´ t in -(2 * r‚Åª¬π)..2 * r‚Åª¬π, 2 := by
        gcongr
        rw [intervalIntegral.integral_of_le, intervalIntegral.integral_of_le]
        rotate_left
        ¬∑ rw [neg_le_self_iff]; positivity
        ¬∑ rw [neg_le_self_iff]; positivity
        refine integral_mono_of_nonneg ?_ (by fun_prop) ?_
        ¬∑ exact ae_of_all _ fun _ ‚Ü¶ by positivity
        ¬∑ refine ae_of_all _ fun x ‚Ü¶ ?_
          calc ‚Äñ1 - charFun (Œº n) (x ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ
          _ ‚â§ ‚Äñ(1 : ‚ÑÇ)‚Äñ + ‚ÄñcharFun (Œº n) (x ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ := norm_sub_le _ _
          _ ‚â§ 1 + 1 := by simp [norm_charFun_le_one]
          _ = 2 := by norm_num
      _ ‚â§ 4 := by
        simp only [neg_mul, intervalIntegral.integral_const, sub_neg_eq_add, smul_eq_mul]
        ring_nf
        rw [mul_inv_cancel‚ÇÄ hr.ne', one_mul]
    ¬∑ exact ENNReal.toReal_nonneg.trans hu.exists.choose_spec
  ¬∑ filter_upwards [eventually_gt_atTop 0] with r hr using h_limsup_le r hr
  -- `‚ä¢ Tendsto (fun r ‚Ü¶ 2‚Åª¬π * r * ‚Äñ‚à´ t in -2 * r‚Åª¬π..2 * r‚Åª¬π, 1 - f (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ)`
  --    `atTop (ùìù 0)`
  -- This will follow from the fact that `f` is continuous at `0`.
  have hf_tendsto := hf.tendsto
  rw [Metric.tendsto_nhds_nhds] at hf_tendsto
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ
  have hf0 : f 0 = 1 := by symm; simpa using h 0
  simp only [gt_iff_lt, dist_eq_norm_sub', zero_sub, norm_neg, hf0] at hf_tendsto
  simp only [ge_iff_le, neg_mul, intervalIntegrable_const, dist_zero_right, norm_mul, norm_inv,
    Real.norm_ofNat, Real.norm_eq_abs, norm_norm]
  simp_rw [abs_of_nonneg (norm_nonneg _)]
  obtain ‚ü®Œ¥, hŒ¥, hŒ¥_lt‚ü© : ‚àÉ Œ¥, 0 < Œ¥ ‚àß ‚àÄ ‚¶Éx : E‚¶Ñ, ‚Äñx‚Äñ < Œ¥ ‚Üí ‚Äñ1 - f x‚Äñ < Œµ / 4 :=
    hf_tendsto (Œµ / 4) (by positivity)
  have h_norm_basis_pos : 0 < ‚ÄñModule.finBasis ‚Ñù E i‚Äñ := by
    simp only [norm_pos_iff, ne_eq]
    exact Basis.ne_zero (Module.finBasis ‚Ñù E) i
  refine ‚ü®4 * Œ¥‚Åª¬π * ‚ÄñModule.finBasis ‚Ñù E i‚Äñ, fun r hrŒ¥ ‚Ü¶ ?_‚ü©
  have hr : 0 < r := lt_of_lt_of_le (by positivity) hrŒ¥
  have h_le_Ioc x (hx : x ‚àà Set.Ioc (-(2 * r‚Åª¬π)) (2 * r‚Åª¬π)) :
      ‚Äñ1 - f (x ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ ‚â§ Œµ / 4 := by
    refine (hŒ¥_lt ?_).le
    rw [norm_smul]
    calc ‚Äñx‚Äñ * ‚ÄñModule.finBasis ‚Ñù E i‚Äñ
    _ ‚â§ 2 * r‚Åª¬π * ‚ÄñModule.finBasis ‚Ñù E i‚Äñ := by
      gcongr
      simp only [Real.norm_eq_abs, abs_le]
      simp only [Set.mem_Ioc] at hx
      exact ‚ü®hx.1.le, hx.2‚ü©
    _ < Œ¥ * ‚ÄñModule.finBasis ‚Ñù E i‚Äñ‚Åª¬π * ‚ÄñModule.finBasis ‚Ñù E i‚Äñ := by
      rw [mul_lt_mul_right h_norm_basis_pos, ‚Üê lt_div_iff‚ÇÄ' (by positivity),
        inv_lt_comm‚ÇÄ hr (by positivity)]
      refine lt_of_lt_of_le ?_ hrŒ¥
      ring_nf
      rw [mul_comm Œ¥‚Åª¬π, inv_inv]
      gcongr
      norm_num
    _ ‚â§ Œ¥ := by
      rw [mul_assoc, inv_mul_cancel‚ÇÄ, mul_one]
      simp only [ne_eq, norm_eq_zero]
      exact Basis.ne_zero (Module.finBasis ‚Ñù E) i
  rw [abs_of_nonneg hr.le]
  calc 2‚Åª¬π * r * ‚Äñ‚à´ t in -(2 * r‚Åª¬π)..2 * r‚Åª¬π, 1 - f (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ
  _ ‚â§ 2‚Åª¬π * r * ‚à´ t in -(2 * r‚Åª¬π)..2 * r‚Åª¬π, ‚Äñ1 - f (t ‚Ä¢ Module.finBasis ‚Ñù E i)‚Äñ := by
    gcongr
    rw [intervalIntegral.integral_of_le, intervalIntegral.integral_of_le]
    ¬∑ exact norm_integral_le_integral_norm _
    ¬∑ rw [neg_le_self_iff]; positivity
    ¬∑ rw [neg_le_self_iff]; positivity
  _ ‚â§ 2‚Åª¬π * r * ‚à´ t in -(2 * r‚Åª¬π)..2 * r‚Åª¬π, Œµ / 4 := by
    gcongr
    rw [intervalIntegral.integral_of_le, intervalIntegral.integral_of_le]
    rotate_left
    ¬∑ rw [neg_le_self_iff]; positivity
    ¬∑ rw [neg_le_self_iff]; positivity
    refine integral_mono_ae ?_ (by fun_prop) ?_
    ¬∑ refine Integrable.mono' (integrable_const (Œµ / 4)) ?_ ?_
      ¬∑ exact Measurable.aestronglyMeasurable <| by fun_prop
      ¬∑ simp_rw [norm_norm]
        exact ae_restrict_of_forall_mem measurableSet_Ioc h_le_Ioc
    ¬∑ exact ae_restrict_of_forall_mem measurableSet_Ioc h_le_Ioc
  _ = Œµ / 2 := by
    simp only [intervalIntegral.integral_div, intervalIntegral.integral_const, sub_neg_eq_add,
      smul_eq_mul]
    ring_nf
    rw [mul_inv_cancel‚ÇÄ hr.ne', one_mul]
  _ < Œµ := by simp [hŒµ]
